var chai, graph;

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  if (!chai) {
    chai = require('chai');
  }
  graph = require('../src/lib/Graph.coffee');
} else {
  graph = require('noflo/src/lib/Graph.js');
}

describe('Unnamed graph instance', function() {
  return it('should have an empty name', function() {
    var g;
    g = new graph.Graph;
    return chai.expect(g.name).to.equal('');
  });
});

describe('Graph', function() {
  describe('with new instance', function() {
    var g;
    g = null;
    it('should get a name from constructor', function() {
      g = new graph.Graph('Foo bar');
      return chai.expect(g.name).to.equal('Foo bar');
    });
    it('should have no nodes initially', function() {
      return chai.expect(g.nodes.length).to.equal(0);
    });
    it('should have no edges initially', function() {
      return chai.expect(g.edges.length).to.equal(0);
    });
    it('should have no initializers initially', function() {
      return chai.expect(g.initializers.length).to.equal(0);
    });
    it('should have no exports initially', function() {
      return chai.expect(g.exports.length).to.equal(0);
    });
    return describe('New node', function() {
      var n;
      n = null;
      it('should emit an event', function(done) {
        g.once('addNode', function(node) {
          chai.expect(node.id).to.equal('Foo');
          chai.expect(node.component).to.equal('Bar');
          n = node;
          return done();
        });
        return g.addNode('Foo', 'Bar');
      });
      it('should be in graph\'s list of nodes', function() {
        chai.expect(g.nodes.length).to.equal(1);
        return chai.expect(g.nodes.indexOf(n)).to.equal(0);
      });
      it('should be accessible via the getter', function() {
        var node;
        node = g.getNode('Foo');
        chai.expect(node.id).to.equal('Foo');
        return chai.expect(node).to.equal(n);
      });
      it('should have empty metadata', function() {
        var node;
        node = g.getNode('Foo');
        chai.expect(JSON.stringify(node.metadata)).to.equal('{}');
        return chai.expect(node.display).to.equal(void 0);
      });
      it('should be available in the JSON export', function() {
        var json;
        json = g.toJSON();
        chai.expect(typeof json.processes.Foo).to.equal('object');
        chai.expect(json.processes.Foo.component).to.equal('Bar');
        return chai.expect(json.processes.Foo.display).to.not.exist;
      });
      it('removing should emit an event', function(done) {
        g.once('removeNode', function(node) {
          chai.expect(node.id).to.equal('Foo');
          chai.expect(node).to.equal(n);
          return done();
        });
        return g.removeNode('Foo');
      });
      return it('should not be available after removal', function() {
        var node;
        node = g.getNode('Foo');
        chai.expect(node).to.not.exist;
        chai.expect(g.nodes.length).to.equal(0);
        return chai.expect(g.nodes.indexOf(n)).to.equal(-1);
      });
    });
  });
  describe('loaded from JSON', function() {
    var g, json;
    json = {
      properties: {
        name: 'Example',
        foo: 'Baz',
        bar: 'Foo'
      },
      exports: [
        {
          "public": 'in',
          "private": 'foo.in',
          metadata: {
            x: 5,
            y: 100
          }
        }, {
          "public": 'out',
          "private": 'bar.out'
        }
      ],
      groups: [
        {
          nodes: ['Foo', 'Bar'],
          metadata: {
            label: 'Main'
          }
        }
      ],
      processes: {
        Foo: {
          component: 'Bar',
          metadata: {
            display: {
              x: 100,
              y: 200
            },
            routes: ['one', 'two']
          }
        },
        Bar: {
          component: 'Baz'
        }
      },
      connections: [
        {
          src: {
            process: 'Foo',
            port: 'out'
          },
          tgt: {
            process: 'Bar',
            port: 'in'
          },
          metadata: {
            route: 'foo'
          }
        }, {
          data: 'Hello, world!',
          tgt: {
            process: 'Foo',
            port: 'in'
          }
        }
      ]
    };
    g = null;
    it('should produce a Graph', function(done) {
      return graph.loadJSON(json, function(instance) {
        g = instance;
        chai.expect(g).to.be.an('object');
        return done();
      });
    });
    it('should have a name', function() {
      return chai.expect(g.name).to.equal('Example');
    });
    it('should have graph metadata intact', function() {
      return chai.expect(g.properties).to.eql({
        foo: 'Baz',
        bar: 'Foo'
      });
    });
    it('should contain two nodes', function() {
      return chai.expect(g.nodes.length).to.equal(2);
    });
    it('the first Node should have its metadata intact', function() {
      var node;
      node = g.getNode('Foo');
      chai.expect(node.metadata).to.be.an('object');
      chai.expect(node.metadata.display).to.be.an('object');
      chai.expect(node.metadata.display.x).to.equal(100);
      chai.expect(node.metadata.display.y).to.equal(200);
      chai.expect(node.metadata.routes).to.be.an('array');
      chai.expect(node.metadata.routes).to.contain('one');
      return chai.expect(node.metadata.routes).to.contain('two');
    });
    it('should contain one connection', function() {
      return chai.expect(g.edges.length).to.equal(1);
    });
    it('the first Edge should have its metadata intact', function() {
      var edge;
      edge = g.edges[0];
      chai.expect(edge.metadata).to.be.an('object');
      return chai.expect(edge.metadata.route).equal('foo');
    });
    it('should contain one IIP', function() {
      return chai.expect(g.initializers.length).to.equal(1);
    });
    it('should contain two exports', function() {
      return chai.expect(g.exports.length).to.equal(2);
    });
    it('should contain one group', function() {
      return chai.expect(g.edges.length).to.equal(1);
    });
    it('should produce same JSON when serialized', function() {
      return chai.expect(JSON.stringify(g.toJSON())).to.equal(JSON.stringify(json));
    });
    describe('renaming a node', function() {
      it('should emit an event', function(done) {
        g.once('renameNode', function(oldId, newId) {
          chai.expect(oldId).to.equal('Foo');
          chai.expect(newId).to.equal('Baz');
          return done();
        });
        return g.renameNode('Foo', 'Baz');
      });
      it('should be available with the new name', function() {
        return chai.expect(g.getNode('Baz')).to.be.an('object');
      });
      it('shouldn\'t be available with the old name', function() {
        return chai.expect(g.getNode('Foo')).to.be["null"];
      });
      it('should have the edge still going from it', function() {
        var connection, edge, _i, _len, _ref;
        connection = null;
        _ref = g.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.from.node === 'Baz') {
            connection = edge;
          }
        }
        return chai.expect(connection).to.be.an('object');
      });
      it('should still be exported', function() {
        var exported, exportedNode, exportedPort, exports, _i, _len, _ref, _ref1;
        exports = 0;
        _ref = g.exports;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          exported = _ref[_i];
          _ref1 = exported["private"].split('.'), exportedNode = _ref1[0], exportedPort = _ref1[1];
          if (exportedNode === 'baz') {
            exports++;
          }
        }
        return chai.expect(exports).to.equal(1);
      });
      it('should still be grouped', function() {
        var group, groups, _i, _len, _ref;
        groups = 0;
        _ref = g.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          if (group.nodes.indexOf('Baz') !== -1) {
            groups++;
          }
        }
        return chai.expect(groups).to.equal(1);
      });
      it('shouldn\'t be have edges with the old name', function() {
        var connection, edge, _i, _len, _ref;
        connection = null;
        _ref = g.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.from.node === 'Foo') {
            connection = edge;
          }
          if (edge.to.node === 'Foo') {
            connection = edge;
          }
        }
        return chai.expect(connection).to.be.a('null');
      });
      it('should have the IIP still going to it', function() {
        var edge, iip, _i, _len, _ref;
        iip = null;
        _ref = g.initializers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.to.node === 'Baz') {
            iip = edge;
          }
        }
        return chai.expect(iip).to.be.an('object');
      });
      it('shouldn\'t have IIPs going to the old name', function() {
        var edge, iip, _i, _len, _ref;
        iip = null;
        _ref = g.initializers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.to.node === 'Foo') {
            iip = edge;
          }
        }
        return chai.expect(iip).to.be.a('null');
      });
      it('shouldn\'t be have export going to the old name', function() {
        var exported, exportedNode, exportedPort, exports, _i, _len, _ref, _ref1;
        exports = 0;
        _ref = g.exports;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          exported = _ref[_i];
          _ref1 = exported["private"].split('.'), exportedNode = _ref1[0], exportedPort = _ref1[1];
          if (exportedNode === 'foo') {
            exports++;
          }
        }
        return chai.expect(exports).to.equal(0);
      });
      return it('shouldn\'t be grouped with the old name', function() {
        var group, groups, _i, _len, _ref;
        groups = 0;
        _ref = g.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          if (group.nodes.indexOf('Foo') !== -1) {
            groups++;
          }
        }
        return chai.expect(groups).to.equal(0);
      });
    });
    return describe('removing a node', function() {
      it('should emit an event', function(done) {
        g.once('removeNode', function(node) {
          chai.expect(node.id).to.equal('Baz');
          return done();
        });
        return g.removeNode('Baz');
      });
      it('shouldn\'t be have edges left behind', function() {
        var connections, edge, _i, _len, _ref;
        connections = 0;
        _ref = g.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.from.node === 'Baz') {
            connections++;
          }
          if (edge.to.node === 'Baz') {
            connections++;
          }
        }
        return chai.expect(connections).to.equal(0);
      });
      it('shouldn\'t be have IIPs left behind', function() {
        var connections, edge, _i, _len, _ref;
        connections = 0;
        _ref = g.initializers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (edge.to.node === 'Baz') {
            connections++;
          }
        }
        return chai.expect(connections).to.equal(0);
      });
      it('shouldn\'t be have exports left behind', function() {
        var exported, exportedNode, exportedPort, exports, _i, _len, _ref, _ref1;
        exports = 0;
        _ref = g.exports;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          exported = _ref[_i];
          _ref1 = exported["private"].split('.'), exportedNode = _ref1[0], exportedPort = _ref1[1];
          if (exportedNode === 'baz') {
            exports++;
          }
        }
        return chai.expect(exports).to.equal(0);
      });
      return it('shouldn\'t be grouped', function() {
        var group, groups, _i, _len, _ref;
        groups = 0;
        _ref = g.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          if (group.nodes.indexOf('Baz') !== -1) {
            groups++;
          }
        }
        return chai.expect(groups).to.equal(0);
      });
    });
  });
  describe('with multiple connected ArrayPorts', function() {
    var g;
    g = new graph.Graph;
    g.addNode('Split1', 'Split');
    g.addNode('Split2', 'Split');
    g.addNode('Merge1', 'Merge');
    g.addNode('Merge2', 'Merge');
    g.addEdge('Split1', 'out', 'Merge1', 'in');
    g.addEdge('Split1', 'out', 'Merge2', 'in');
    g.addEdge('Split2', 'out', 'Merge1', 'in');
    g.addEdge('Split2', 'out', 'Merge2', 'in');
    it('should contain four nodes', function() {
      return chai.expect(g.nodes.length).to.equal(4);
    });
    it('should contain four edges', function() {
      return chai.expect(g.edges.length).to.equal(4);
    });
    it('should allow a specific edge to be removed', function() {
      g.removeEdge('Split1', 'out', 'Merge2', 'in');
      return chai.expect(g.edges.length).to.equal(3);
    });
    it('shouldn\'t contain the removed connection from Split1', function() {
      var connection, edge, _i, _len, _ref;
      connection = null;
      _ref = g.edges;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.from.node === 'Split1' && edge.to.node === 'Merge2') {
          connection = edge;
        }
      }
      return chai.expect(connection).to.be["null"];
    });
    return it('should still contain the other connection from Split1', function() {
      var connection, edge, _i, _len, _ref;
      connection = null;
      _ref = g.edges;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge.from.node === 'Split1' && edge.to.node === 'Merge1') {
          connection = edge;
        }
      }
      return chai.expect(connection).to.be.an('object');
    });
  });
  describe('with an Initial Information Packet', function() {
    var g;
    g = new graph.Graph;
    g.addNode('Split', 'Split');
    g.addInitial('Foo', 'Split', 'in');
    it('should contain one node', function() {
      return chai.expect(g.nodes.length).to.equal(1);
    });
    it('should contain no edges', function() {
      return chai.expect(g.edges.length).to.equal(0);
    });
    it('should contain one IIP', function() {
      return chai.expect(g.initializers.length).to.equal(1);
    });
    return describe('on removing that IIP', function() {
      it('should emit a removeInitial event', function(done) {
        g.once('removeInitial', function(iip) {
          chai.expect(iip.from.data).to.equal('Foo');
          chai.expect(iip.to.node).to.equal('Split');
          chai.expect(iip.to.port).to.equal('in');
          return done();
        });
        return g.removeInitial('Split', 'in');
      });
      return it('should contain no IIPs', function() {
        return chai.expect(g.initializers.length).to.equal(0);
      });
    });
  });
  return describe('with no nodes', function() {
    var g;
    g = new graph.Graph;
    it('should not allow adding edges', function() {
      g.addEdge('Foo', 'out', 'Bar', 'in');
      return chai.expect(graph.edges).to.be.empty;
    });
    return it('should not allow adding IIPs', function() {
      g.addInitial('Hello', 'Bar', 'in');
      return chai.expect(graph.initializers).to.be.empty;
    });
  });
});
