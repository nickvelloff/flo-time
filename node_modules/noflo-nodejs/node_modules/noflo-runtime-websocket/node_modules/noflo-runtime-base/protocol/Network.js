(function() {
  var EventEmitter, NetworkProtocol, getConnectionSignature, getEdgeSignature, getPortSignature, getSocketSignature, noflo, prepareSocketEvent,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  noflo = require('noflo');

  EventEmitter = require('events').EventEmitter;

  prepareSocketEvent = function(event, req) {
    var payload;
    payload = {
      id: event.id,
      graph: req.graph
    };
    if (event.socket.from) {
      payload.src = {
        node: event.socket.from.process.id,
        port: event.socket.from.port
      };
    }
    if (event.socket.to) {
      payload.tgt = {
        node: event.socket.to.process.id,
        port: event.socket.to.port
      };
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    if (event.group) {
      payload.group = event.group;
    }
    if (event.data) {
      if (!noflo.isBrowser()) {
        if (Buffer.isBuffer(event.data)) {
          event.data = event.data.slice(0, 20);
        }
      }
      if (event.data.toJSON) {
        payload.data = event.data.toJSON();
      }
      if (event.data.toString) {
        payload.data = event.data.toString();
        if (payload.data === '[object Object]') {
          try {
            payload.data = JSON.parse(JSON.stringify(event.data));
          } catch (_error) {}
        }
      } else {
        payload.data = event.data;
      }
    }
    if (event.subgraph) {
      payload.subgraph = event.subgraph;
    }
    return payload;
  };

  getPortSignature = function(item) {
    if (!item) {
      return '';
    }
    return item.process + '(' + item.port + ')';
  };

  getEdgeSignature = function(edge) {
    return getPortSignature(edge.src) + ' -> ' + getPortSignature(edge.tgt);
  };

  getConnectionSignature = function(connection) {
    if (!connection) {
      return '';
    }
    return connection.process.id + '(' + connection.port + ')';
  };

  getSocketSignature = function(socket) {
    return getConnectionSignature(socket.from) + ' -> ' + getConnectionSignature(socket.to);
  };

  NetworkProtocol = (function(_super) {
    __extends(NetworkProtocol, _super);

    function NetworkProtocol(transport) {
      this.transport = transport;
      this.networks = {};
    }

    NetworkProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('network', topic, payload, context);
    };

    NetworkProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('network', topic, payload);
    };

    NetworkProtocol.prototype.receive = function(topic, payload, context) {
      var graph;
      if (topic !== 'list') {
        graph = this.resolveGraph(payload, context);
        if (!graph) {
          return;
        }
      }
      switch (topic) {
        case 'start':
          return this.startNetwork(graph, payload, context);
        case 'stop':
          return this.stopNetwork(graph, payload, context);
        case 'edges':
          return this.updateEdgesFilter(graph, payload, context);
        case 'debug':
          return this.debugNetwork(graph, payload, context);
        case 'getstatus':
          return this.getStatus(graph, payload, context);
      }
    };

    NetworkProtocol.prototype.resolveGraph = function(payload, context) {
      if (!payload.graph) {
        this.send('error', new Error('No graph specified'), context);
        return;
      }
      if (!this.transport.graph.graphs[payload.graph]) {
        this.send('error', new Error('Requested graph not found'), context);
        return;
      }
      return this.transport.graph.graphs[payload.graph];
    };

    NetworkProtocol.prototype.updateEdgesFilter = function(graph, payload, context) {
      var edge, network, signature, _i, _len, _ref, _results;
      network = this.networks[payload.graph];
      if (network) {
        network.filters = {};
      } else {
        network = {
          network: null,
          filters: {}
        };
        this.networks[payload.graph] = network;
      }
      _ref = payload.edges;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        signature = getEdgeSignature(edge);
        _results.push(network.filters[signature] = true);
      }
      return _results;
    };

    NetworkProtocol.prototype.eventFiltered = function(graph, event) {
      var sign;
      if (!this.transport.options.filterData) {
        return true;
      }
      sign = getSocketSignature(event.socket);
      return this.networks[graph].filters[sign];
    };

    NetworkProtocol.prototype.initNetwork = function(graph, payload, context) {
      var network;
      if (this.networks[payload.graph]) {
        network = this.networks[payload.graph].network;
        network.stop();
        delete this.networks[payload.graph];
        this.emit('removenetwork', network, this.networks);
      }
      graph.componentLoader = this.transport.component.getLoader(graph.baseDir);
      return noflo.createNetwork(graph, (function(_this) {
        return function(network) {
          if (_this.networks[payload.graph]) {
            _this.networks[payload.graph].network = network;
          } else {
            _this.networks[payload.graph] = {
              network: network,
              filters: {}
            };
          }
          _this.emit('addnetwork', network, _this.networks);
          _this.subscribeNetwork(network, payload, context);
          return network.connect(function() {
            return network.start();
          });
        };
      })(this), true);
    };

    NetworkProtocol.prototype.subscribeNetwork = function(network, payload, context) {
      network.on('start', (function(_this) {
        return function(event) {
          return _this.sendAll('started', {
            time: event.start,
            graph: payload.graph,
            running: true,
            started: network.isStarted()
          }, context);
        };
      })(this));
      network.on('end', (function(_this) {
        return function(event) {
          return _this.sendAll('stopped', {
            time: new Date,
            uptime: event.uptime,
            graph: payload.graph,
            running: false,
            started: network.isStarted()
          }, context);
        };
      })(this));
      network.on('icon', (function(_this) {
        return function(event) {
          event.graph = payload.graph;
          return _this.sendAll('icon', event, context);
        };
      })(this));
      network.on('connect', (function(_this) {
        return function(event) {
          return _this.sendAll('connect', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('begingroup', (function(_this) {
        return function(event) {
          return _this.sendAll('begingroup', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('data', (function(_this) {
        return function(event) {
          if (!_this.eventFiltered(payload.graph, event)) {
            return;
          }
          return _this.sendAll('data', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('endgroup', (function(_this) {
        return function(event) {
          return _this.sendAll('endgroup', prepareSocketEvent(event, payload), context);
        };
      })(this));
      network.on('disconnect', (function(_this) {
        return function(event) {
          return _this.sendAll('disconnect', prepareSocketEvent(event, payload), context);
        };
      })(this));
      return network.on('process-error', (function(_this) {
        return function(event) {
          var bt, error, i, _i, _ref;
          error = event.error.message;
          if (event.error.stack) {
            bt = event.error.stack.split('\n');
            for (i = _i = 0, _ref = Math.min(bt.length, 3); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              error += "\n" + bt[i];
            }
          }
          return _this.sendAll('processerror', {
            id: event.id,
            error: error,
            graph: payload.graph
          }, context);
        };
      })(this));
    };

    NetworkProtocol.prototype.startNetwork = function(graph, payload, context) {
      var network;
      network = this.networks[payload.graph];
      if (network) {
        return network.network.start();
      } else {
        return this.initNetwork(graph, payload, context);
      }
    };

    NetworkProtocol.prototype.stopNetwork = function(graph, payload, context) {
      if (!this.networks[payload.graph]) {
        return;
      }
      return this.networks[payload.graph].network.stop();
    };

    NetworkProtocol.prototype.debugNetwork = function(graph, payload, context) {
      var net;
      if (!this.networks[payload.graph]) {
        return;
      }
      net = this.networks[payload.graph].network;
      if (net.setDebug != null) {
        return net.setDebug(payload.enable);
      } else {
        return console.log('Warning: Network.setDebug not supported. Update to newer NoFlo');
      }
    };

    NetworkProtocol.prototype.getStatus = function(graph, payload, context) {
      var isRunning, network;
      network = this.networks[payload.graph];
      if (!network) {
        return;
      }
      if (network.network.isRunning) {
        isRunning = network.network.isRunning();
      } else {
        isRunning = network.network.isStarted() && network.network.connectionCount > 0;
      }
      return this.send('status', {
        graph: payload.graph,
        running: isRunning,
        started: network.network.isStarted()
      }, context);
    };

    return NetworkProtocol;

  })(EventEmitter);

  module.exports = NetworkProtocol;

}).call(this);
