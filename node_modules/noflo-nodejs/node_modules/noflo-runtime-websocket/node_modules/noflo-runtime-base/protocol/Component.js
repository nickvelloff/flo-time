(function() {
  var ComponentProtocol, noflo, _;

  noflo = require('noflo');

  _ = require('underscore');

  ComponentProtocol = (function() {
    ComponentProtocol.prototype.loaders = {};

    function ComponentProtocol(transport) {
      this.transport = transport;
    }

    ComponentProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('component', topic, payload, context);
    };

    ComponentProtocol.prototype.receive = function(topic, payload, context) {
      switch (topic) {
        case 'list':
          return this.listComponents(payload, context);
        case 'getsource':
          return this.getSource(payload, context);
        case 'source':
          return this.setSource(payload, context);
      }
    };

    ComponentProtocol.prototype.getLoader = function(baseDir) {
      if (!this.loaders[baseDir]) {
        this.loaders[baseDir] = new noflo.ComponentLoader(baseDir);
      }
      return this.loaders[baseDir];
    };

    ComponentProtocol.prototype.listComponents = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.listComponents((function(_this) {
        return function(components) {
          return Object.keys(components).forEach(function(component) {
            return _this.processComponent(loader, component, context);
          });
        };
      })(this));
    };

    ComponentProtocol.prototype.getSource = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.getSource(payload.name, (function(_this) {
        return function(err, component) {
          var graph, nameParts;
          if (err) {
            graph = _this.transport.graph.graphs[payload.name];
            if (graph == null) {
              _this.send('error', err, context);
              return;
            }
            nameParts = payload.name.split('/');
            return _this.send('source', {
              name: nameParts[1],
              library: nameParts[0],
              code: JSON.stringify(graph.toJSON()),
              language: 'json'
            }, context);
          } else {
            return _this.send('source', component, context);
          }
        };
      })(this));
    };

    ComponentProtocol.prototype.setSource = function(payload, context) {
      var baseDir, loader;
      baseDir = this.transport.options.baseDir;
      loader = this.getLoader(baseDir);
      return loader.setSource(payload.library, payload.name, payload.code, payload.language, (function(_this) {
        return function(err) {
          if (err) {
            _this.send('error', err, context);
            return;
          }
          return _this.processComponent(loader, loader.normalizeName(payload.library, payload.name), context);
        };
      })(this));
    };

    ComponentProtocol.prototype.processComponent = function(loader, component, context) {
      return loader.load(component, (function(_this) {
        return function(err, instance) {
          if (!instance) {
            if (err instanceof Error) {
              _this.send('error', err, context);
              return;
            }
            instance = err;
          }
          if (!instance.isReady()) {
            instance.once('ready', function() {
              return _this.sendComponent(component, instance, context);
            });
            return;
          }
          return _this.sendComponent(component, instance, context);
        };
      })(this), true);
    };

    ComponentProtocol.prototype.sendComponent = function(component, instance, context) {
      var icon, inPorts, outPorts, port, portName, _ref, _ref1;
      inPorts = [];
      outPorts = [];
      _ref = instance.inPorts;
      for (portName in _ref) {
        port = _ref[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        inPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0,
          values: port.options && port.options.values ? port.options.values : void 0,
          "default": port.options && port.options["default"] ? port.options["default"] : void 0
        });
      }
      _ref1 = instance.outPorts;
      for (portName in _ref1) {
        port = _ref1[portName];
        if (!port || typeof port === 'function' || !port.canAttach) {
          continue;
        }
        outPorts.push({
          id: portName,
          type: port.getDataType ? port.getDataType() : void 0,
          required: port.isRequired ? port.isRequired() : void 0,
          addressable: port.isAddressable ? port.isAddressable() : void 0,
          description: port.getDescription ? port.getDescription() : void 0
        });
      }
      icon = instance.getIcon ? instance.getIcon() : 'blank';
      return this.send('component', {
        name: component,
        description: instance.description,
        subgraph: instance.isSubgraph(),
        icon: icon,
        inPorts: inPorts,
        outPorts: outPorts
      }, context);
    };

    ComponentProtocol.prototype.registerGraph = function(id, graph, context) {
      var loader, send, sender;
      sender = (function(_this) {
        return function() {
          return _this.processComponent(loader, id, context);
        };
      })(this);
      send = _.debounce(sender, 10);
      loader = this.getLoader(graph.baseDir);
      loader.listComponents((function(_this) {
        return function(components) {
          loader.registerComponent('', id, graph);
          return send();
        };
      })(this));
      graph.on('addNode', send);
      graph.on('removeNode', send);
      graph.on('renameNode', send);
      graph.on('addEdge', send);
      graph.on('removeEdge', send);
      graph.on('addInitial', send);
      graph.on('removeInitial', send);
      graph.on('addInport', send);
      graph.on('removeInport', send);
      graph.on('renameInport', send);
      graph.on('addOutport', send);
      graph.on('removeOutport', send);
      return graph.on('renameOutport', send);
    };

    return ComponentProtocol;

  })();

  module.exports = ComponentProtocol;

}).call(this);
