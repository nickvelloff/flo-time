(function() {
  var RuntimeProtocol, noflo;

  noflo = require('noflo');

  RuntimeProtocol = (function() {
    function RuntimeProtocol(transport) {
      this.transport = transport;
      this.mainGraph = null;
      this.outputSockets = {};
      this.transport.network.on('addnetwork', (function(_this) {
        return function(network) {
          network.on('start', function() {
            network = _this.getMainNetwork();
            return _this.updateOutportSubscription(network);
          });
          return network.on('data', function(event) {});
        };
      })(this));
      this.transport.network.on('removenetwork', (function(_this) {
        return function() {
          var network;
          network = _this.getMainNetwork();
          return _this.updateOutportSubscription(network);
        };
      })(this));
    }

    RuntimeProtocol.prototype.send = function(topic, payload, context) {
      return this.transport.send('runtime', topic, payload, context);
    };

    RuntimeProtocol.prototype.sendAll = function(topic, payload) {
      return this.transport.sendAll('runtime', topic, payload);
    };

    RuntimeProtocol.prototype.receive = function(topic, payload, context) {
      switch (topic) {
        case 'getruntime':
          return this.getRuntime(payload, context);
        case 'packet':
          return this.receivePacket(payload, context);
      }
    };

    RuntimeProtocol.prototype.getRuntime = function(payload, context) {
      var capabilities, graph, graphInstance, k, type, v, _ref;
      type = this.transport.options.type;
      if (!type) {
        if (noflo.isBrowser()) {
          type = 'noflo-browser';
        } else {
          type = 'noflo-nodejs';
        }
      }
      capabilities = this.transport.options.capabilities;
      if (!capabilities) {
        capabilities = ['protocol:graph', 'protocol:component', 'protocol:network', 'protocol:runtime', 'component:setsource', 'component:getsource'];
      }
      graph = void 0;
      _ref = this.transport.network.networks;
      for (k in _ref) {
        v = _ref[k];
        graph = k;
        break;
      }
      this.send('runtime', {
        type: type,
        version: this.transport.version,
        capabilities: capabilities,
        graph: graph
      }, context);
      graphInstance = this.transport.graph.graphs[graph];
      return this.sendPorts(graph, graphInstance, context);
    };

    RuntimeProtocol.prototype.sendPorts = function(name, graph, context) {
      var inports, internal, outports, pub, _ref, _ref1, _ref2, _ref3;
      inports = [];
      outports = [];
      if (graph) {
        _ref = graph.inports;
        for (pub in _ref) {
          internal = _ref[pub];
          inports.push({
            id: pub,
            type: 'any',
            description: (_ref1 = internal.metadata) != null ? _ref1.description : void 0,
            addressable: false,
            required: false
          });
        }
        _ref2 = graph.outports;
        for (pub in _ref2) {
          internal = _ref2[pub];
          outports.push({
            id: pub,
            type: 'any',
            description: (_ref3 = internal.metadata) != null ? _ref3.description : void 0,
            addressable: false,
            required: false
          });
        }
      }
      return this.sendAll('ports', {
        graph: name,
        inPorts: inports,
        outPorts: outports
      }, context);
    };

    RuntimeProtocol.prototype.getMainNetwork = function() {
      var graphName, network;
      if (!this.mainGraph) {
        return null;
      }
      graphName = this.mainGraph.name || this.mainGraph.properties.id;
      network = this.transport.network.networks[graphName];
      if (!network) {
        return null;
      }
      network = network.network;
      return network;
    };

    RuntimeProtocol.prototype.setMainGraph = function(id, graph, context) {
      var checkExportedPorts, d, dependencies, _i, _j, _len, _len1, _results;
      checkExportedPorts = (function(_this) {
        return function(name, process, port, metadata) {
          _this.sendPorts(id, graph, context);
          return _this.updateOutportSubscription(_this.getMainNetwork());
        };
      })(this);
      dependencies = ['addInport', 'addOutport', 'removeInport', 'removeOutport'];
      if (this.mainGraph) {
        for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
          d = dependencies[_i];
          this.mainGraph.removeListener(d, checkExportedPorts);
        }
      }
      this.mainGraph = graph;
      _results = [];
      for (_j = 0, _len1 = dependencies.length; _j < _len1; _j++) {
        d = dependencies[_j];
        _results.push(this.mainGraph.on(d, checkExportedPorts));
      }
      return _results;
    };

    RuntimeProtocol.prototype.updateOutportSubscription = function(network) {
      var component, event, events, graphName, internal, pub, sendFunc, socket, _i, _len, _ref, _ref1, _results;
      if (!network) {
        return;
      }
      events = ['data', 'begingroup', 'endgroup', 'connect', 'disconnect'];
      _ref = this.outputSockets;
      for (pub in _ref) {
        socket = _ref[pub];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          socket.removeAllListeners(event);
        }
      }
      this.outputSockets = {};
      graphName = network.graph.name || network.graph.properties.id;
      _ref1 = network.graph.outports;
      _results = [];
      for (pub in _ref1) {
        internal = _ref1[pub];
        socket = noflo.internalSocket.createSocket();
        this.outputSockets[pub] = socket;
        component = network.processes[internal.process].component;
        component.outPorts[internal.port].attach(socket);
        sendFunc = (function(_this) {
          return function(event) {
            return function(payload) {
              return _this.sendAll('runtime', 'packet', {
                port: pub,
                event: event,
                graph: graphName,
                payload: payload
              });
            };
          };
        })(this);
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
            event = events[_j];
            _results1.push(socket.on(event, sendFunc(event)));
          }
          return _results1;
        })());
      }
      return _results;
    };

    RuntimeProtocol.prototype.receivePacket = function(payload, context) {
      var component, graphName, internal, network, port, socket;
      if (!this.mainGraph) {
        return this.send('error', new Error('No main graph'), context);
      }
      graphName = this.mainGraph.name || this.mainGraph.properties.id;
      network = this.getMainNetwork();
      internal = this.mainGraph.inports[payload.port];
      component = network.processes[internal.process].component;
      socket = noflo.internalSocket.createSocket();
      port = component.inPorts[internal.port];
      port.attach(socket);
      switch (payload.event) {
        case 'connect':
          socket.connect();
          break;
        case 'disconnect':
          socket.disconnect();
          break;
        case 'begingroup':
          socket.beginGroup(payload.payload);
          break;
        case 'endgroup':
          socket.endGroup(payload.payload);
          break;
        case 'data':
          socket.send(payload.payload);
      }
      return port.detach(socket);
    };

    return RuntimeProtocol;

  })();

  module.exports = RuntimeProtocol;

}).call(this);
